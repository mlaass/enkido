/**
 * Build script to generate the F1 help lookup index from markdown documentation.
 * Run with: bun scripts/build-docs-index.ts
 */

import { readdir, readFile, writeFile } from 'fs/promises';
import { join } from 'path';
import matter from 'gray-matter';

interface LookupEntry {
	keyword: string;
	slug: string;
	category: string;
	title: string;
	anchor?: string;
}

const DOCS_DIR = join(import.meta.dir, '../static/docs');
const OUTPUT_FILE = join(import.meta.dir, '../src/lib/docs/lookup-index.ts');

async function findMarkdownFiles(dir: string): Promise<string[]> {
	const files: string[] = [];
	const entries = await readdir(dir, { withFileTypes: true });

	for (const entry of entries) {
		const fullPath = join(dir, entry.name);
		if (entry.isDirectory()) {
			files.push(...await findMarkdownFiles(fullPath));
		} else if (entry.name.endsWith('.md')) {
			files.push(fullPath);
		}
	}

	return files;
}

function extractHeadings(content: string): Array<{ level: number; text: string; id: string }> {
	const headings: Array<{ level: number; text: string; id: string }> = [];
	const headingRegex = /^(#{1,6})\s+(.+)$/gm;

	let match;
	while ((match = headingRegex.exec(content)) !== null) {
		const level = match[1].length;
		const text = match[2].trim();
		const id = text
			.toLowerCase()
			.replace(/[^a-z0-9]+/g, '-')
			.replace(/^-|-$/g, '');
		headings.push({ level, text, id });
	}

	return headings;
}

async function buildIndex(): Promise<Map<string, LookupEntry>> {
	const index = new Map<string, LookupEntry>();
	const files = await findMarkdownFiles(DOCS_DIR);

	for (const filePath of files) {
		const relativePath = filePath.replace(DOCS_DIR + '/', '');
		const raw = await readFile(filePath, 'utf-8');
		const { data: frontmatter, content } = matter(raw);

		if (!frontmatter.title || !frontmatter.category) {
			console.warn(`Skipping ${relativePath}: missing title or category`);
			continue;
		}

		const slug = relativePath
			.replace(/\.md$/, '')
			.split('/')
			.pop() || relativePath;

		// For builtins, index h2 headings first (they have anchors)
		if (frontmatter.category === 'builtins') {
			const headings = extractHeadings(content);
			for (const heading of headings) {
				if (heading.level === 2) {
					const key = heading.text.toLowerCase();
					index.set(key, {
						keyword: key,
						slug,
						category: frontmatter.category,
						title: heading.text,
						anchor: heading.id
					});
				}
			}
		}

		// Add frontmatter keywords (won't overwrite h2 entries with anchors)
		if (Array.isArray(frontmatter.keywords)) {
			for (const keyword of frontmatter.keywords) {
				const key = keyword.toLowerCase();
				if (!index.has(key)) {
					index.set(key, {
						keyword: key,
						slug,
						category: frontmatter.category,
						title: frontmatter.title
					});
				}
			}
		}
	}

	return index;
}

async function main() {
	console.log('Building docs lookup index...');
	const index = await buildIndex();

	// Convert to object for output
	const entries: Record<string, LookupEntry> = {};
	for (const [key, value] of index) {
		entries[key] = value;
	}

	const output = `// Auto-generated by scripts/build-docs-index.ts
// Do not edit manually - run: bun scripts/build-docs-index.ts

import type { LookupEntry } from './types';

export const lookupIndex: Record<string, LookupEntry> = ${JSON.stringify(entries, null, '\t')};
`;

	await writeFile(OUTPUT_FILE, output);
	console.log(`Generated ${OUTPUT_FILE} with ${index.size} entries`);
}

main().catch(console.error);
